# ES2022 (ES13)

ECMAScript 2022 (ES13) 是一个重要的版本，它为类（Class）带来了期待已久的私有成员和静态初始化块等功能，并正式确定了顶层 `await`，使得模块处理异步初始化变得更加容易。

## 1. 类（Class）的增强

ES2022 对类进行了多项重要增强，使其功能更加完善。

### 私有实例字段和方法

通过在字段或方法名前添加 `#` 前缀，可以创建私有成员。私有成员只能在类的内部被访问，外部访问会抛出语法错误。

```javascript
class Counter {
  // 私有字段
  #count = 0;

  // 公共方法
  increment() {
    this.#count++;
  }

  // 私有方法
  #log() {
    console.log(`Current count: ${this.#count}`);
  }

  report() {
    this.#log();
  }
}

const c = new Counter();
c.increment();
c.report(); // "Current count: 1"

// console.log(c.#count); // SyntaxError: Private field '#count' must be declared in an enclosing class
```

### 静态初始化块 `static {}`

静态初始化块提供了一种在类声明时执行静态初始化的灵活方式，可以访问类的静态私有字段。

```javascript
class MyClass {
  static #privateStaticField = 1;
  static publicStaticField;

  static {
    // 可以在这里编写复杂的静态初始化逻辑
    this.publicStaticField = this.#privateStaticField * 2;
  }
}

console.log(MyClass.publicStaticField); // 2
```

## 2. 顶层 `await` (Top-level await)

我们已在 `async/await` 章节中提及，ES2022 正式将其标准化。现在，你可以在模块的顶层直接使用 `await`，而无需将其包裹在 `async` 函数中。

这在模块需要进行异步初始化（例如，从 API 获取配置、连接数据库）时非常有用。依赖该模块的其他模块会等待这个模块的异步操作完成后再执行。

```javascript
// a-module.js
const config = await (await fetch('/api/config')).json();
export default config;

// b-module.js
import config from './a-module.js';
// 这里的 config 已经是解析完成的对象
console.log(config);
```

## 3. `.at()` 方法

`at()` 方法为所有可索引的类型（`Array`, `String`, `TypedArray`）提供了一种新的访问元素的方式。它接收一个整数作为参数，并返回该索引处的项。

它最大的优点是支持**负数索引**，`-1` 表示最后一个元素，`-2` 表示倒数第二个，以此类推。这比 `arr[arr.length - 1]` 的写法要简洁得多。

```javascript
const arr = ['a', 'b', 'c', 'd'];

// 获取最后一个元素
console.log(arr.at(-1)); // 'd'
console.log(arr[arr.length - 1]); // 'd'

// 获取第一个元素
console.log(arr.at(0)); // 'a'
```

## 4. `Object.hasOwn(obj, prop)`

`Object.prototype.hasOwnProperty()` 是一个常用的方法，用于检查一个对象是否拥有指定的自有属性。但它存在一些问题，例如，如果一个对象是通过 `Object.create(null)` 创建的，它就没有继承 `hasOwnProperty` 方法。

`Object.hasOwn()` 是一个静态方法，它提供了一种更安全、更可靠的方式来替代 `hasOwnProperty`。

```javascript
const person = { name: 'Yorke' };
console.log(Object.hasOwn(person, 'name')); // true
console.log(Object.hasOwn(person, 'toString')); // false (toString 是继承的)

const objWithNullProto = Object.create(null);
objWithNullProto.prop = 'exists';
// objWithNullProto.hasOwnProperty('prop'); // TypeError
console.log(Object.hasOwn(objWithNullProto, 'prop')); // true
```

## 5. 错误原因 `error.cause`

`Error` 构造函数现在可以接受第二个参数，一个包含 `cause` 属性的对象。这允许你指定导致当前错误的原始错误，形成一个清晰的错误链，非常有助于调试。

```javascript
async function doJob() {
  try {
    await fetch('//invalid-url');
  } catch (error) {
    // 将原始的 fetch 错误作为新错误的原因
    throw new Error('Failed to complete the job.', { cause: error });
  }
}

try {
  await doJob();
} catch (e) {
  console.log('Job failed:', e.message);
  console.log('Caused by:', e.cause); // 原始的 TypeError
}