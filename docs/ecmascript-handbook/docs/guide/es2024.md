# ES2024 (ES15)

ECMAScript 2024 的变更不多，但引入了一个非常实用且容易忽视的改进：字符串良构性（well‑formedness）检测与修复。它直接提升了我们在处理 Unicode 字符串（尤其是表情符号、跨语言文本等）时的健壮性与可预期性。

本文遵循本手册统一结构，提供背景、API 讲解、最小可复现示例、边界与兼容性建议以及 FAQ。

## 1. 背景与动机

JavaScript 字符串底层以 UTF‑16 代码单元存储。某些 Unicode 字符（如大部分 emoji）需要用一对「代理项（surrogate pair）」来表示：一个高位代理项（high surrogate，范围 0xD800–0xDBFF）加上一个低位代理项（low surrogate，范围 0xDC00–0xDFFF）。如果字符串中出现了「落单」的代理项（例如只有高位或只有低位，二者未成对），该字符串即为「非良构（ill‑formed）」。

非良构字符串常见于：
- 错误的字符串拼接或截断（如在代理项之间切分）
- 来自不规范的外部输入或历史数据
- 处理二进制到字符串的错误解码

ES2024 引入的两个新方法让我们可以：
- 快速检测字符串是否良构：String.prototype.isWellFormed()
- 将非良构字符串修复为良构：String.prototype.toWellFormed()

## 2. API 与语义

### 2.1 String.prototype.isWellFormed() -> boolean
- 返回当前字符串是否为「良构」的 UTF‑16 序列（不存在落单代理项）。
- 不会修改原字符串。

### 2.2 String.prototype.toWellFormed() -> string
- 返回一个新字符串，其中所有非良构的部分会被替换为 U+FFFD（替换字符，）。
- 原字符串不变。

这两个方法一快一稳：先用 isWellFormed() 做「只读校验」，必要时再用 toWellFormed() 做「修复并继续处理」。

## 3. 最小可复现示例

### 3.1 检测良构与修复

```js
// 一个正常的 emoji（良构，两个代码单元组成一对代理项）
const smile = '😊';           // U+1F60A
console.log(smile.length);    // 2
console.log(smile.isWellFormed()); // true
console.log(smile.toWellFormed()); // '😊'（不变）

// 构造一个“落单”的高位代理项（非良构示例）
const loneHigh = '\uD83D';    // 高位代理项，单独出现
console.log(loneHigh.isWellFormed()); // false
console.log(loneHigh.toWellFormed()); // ''（替换为 U+FFFD）

// 一个混合字符串，包含良构 emoji 和落单代理项
const s = 'OK ' + smile + ' ' + loneHigh + ' end';
console.log(s.isWellFormed()); // false
console.log(s.toWellFormed()); // 'OK 😊  end'
```

### 3.2 避免截断破坏良构

```js
const rocket = '🚀'; // U+1F680，长度为 2
console.log(rocket.length); // 2

// 错误的切片：把代理项切开了（非良构）
const badSlice = rocket.slice(0, 1);
console.log(badSlice.isWellFormed()); // false

// 在继续展示/存储之前进行修复
const safe = badSlice.toWellFormed();
console.log(safe); // ''
```

### 3.3 在输入/存储边界使用保护

```js
function persist(text) {
  // 入库前确保良构，避免后续处理报错或显示异常
  const normalized = text.isWellFormed() ? text : text.toWellFormed();
  // 写入数据库/日志/缓存……
  return normalized;
}

persist('Hello 😊');     // 原样存储
persist('Hello \uD83D'); // 存为 'Hello '
```

## 4. 边界与陷阱

- 替换策略：toWellFormed() 会使用 U+FFFD 替换「每一个」非良构位置；它不会尝试“猜测原字符”或智能修复。
- 正规化与 NFC/NFD：该 API 仅关注 UTF‑16 良构性，不涉及 Unicode 规范化（如 NFC、NFD）。如需规范化请另行使用 String.prototype.normalize()。
- 长度与索引：良构性与 .length 的关系微妙。含 emoji 的字符串 length 可能大于字符的直观数量；不要依赖 .length 来表示“字符数”，显示层面的字符应考虑 code point 或 grapheme（需借助 Intl.Segmenter 等）。
- I/O 边界：非良构数据常见于 I/O 边界（网络、文件、编解码）。推荐在输入尽早检测与修复，或在关键处理/入库前进行一次防护。

## 5. 兼容性与迁移建议

- 标准：本特性收录于 ES2024。
- 运行时支持：现代浏览器与新版本 Node.js 已逐步支持该特性。面向广泛用户时，建议配合“特性检测 + 轻量 polyfill”策略。
- 构建链：一般无需转译支持；若目标环境较旧，可通过运行时 polyfill 兜底。

### 5.1 兼容矩阵（参考）
以下为 String.prototype.isWellFormed / toWellFormed 的支持概览。具体版本以 MDN/引擎发布记录为准，建议在项目中使用特性检测确保安全回退。

| 运行时 | 版本 | isWellFormed | toWellFormed |
| --- | --- | --- | --- |
| Chrome | 最新稳定版与近几大版本 | 支持 | 支持 |
| Edge | 最新稳定版与近几大版本 | 支持 | 支持 |
| Firefox | 最新稳定版与近几大版本 | 支持 | 支持 |
| Safari | 最新稳定版与近几大版本 | 支持 | 支持 |
| Node.js | 最新 LTS 与 Current | 支持 | 支持 |

特性检测与安全回退：
```js
const hasWellFormed =
  typeof String.prototype.isWellFormed === 'function' &&
  typeof String.prototype.toWellFormed === 'function';

function ensureWellFormed(s) {
  if (typeof s !== 'string') s = String(s);
  return hasWellFormed ? (s.isWellFormed() ? s : s.toWellFormed()) : s; // 无原生则原样返回或接入 polyfill
}
```

参考链接：
- MDN: String.prototype.isWellFormed / toWellFormed
- TC39: https://github.com/tc39/proposal-is-usv-string

### 5.2 轻量 Polyfill（功能子集）

下面的实现示例仅用于基本环境兜底，覆盖核心语义。性能与覆盖面与原生实现可能有差距，但足以满足大多数场景。

```js
(function polyfillWellFormed() {
  if (typeof String.prototype.isWellFormed !== 'function') {
    Object.defineProperty(String.prototype, 'isWellFormed', {
      value: function () {
        const s = String(this);
        for (let i = 0; i < s.length; i++) {
          const c = s.charCodeAt(i);
          if (c >= 0xD800 && c <= 0xDBFF) { // high surrogate
            const next = s.charCodeAt(i + 1);
            if (!(next >= 0xDC00 && next <= 0xDFFF)) return false;
            i++; // skip the low surrogate
          } else if (c >= 0xDC00 && c <= 0xDFFF) { // lone low surrogate
            return false;
          }
        }
        return true;
      },
      configurable: true
    });
  }

  if (typeof String.prototype.toWellFormed !== 'function') {
    const REPLACEMENT = '\uFFFD';
    Object.defineProperty(String.prototype, 'toWellFormed', {
      value: function () {
        const s = String(this);
        let out = '';
        for (let i = 0; i < s.length; i++) {
          const c = s.charCodeAt(i);
          if (c >= 0xD800 && c <= 0xDBFF) { // high surrogate
            const next = s.charCodeAt(i + 1);
            if (next >= 0xDC00 && next <= 0xDFFF) {
              out += s[i] + s[i + 1];
              i++; // consume pair
            } else {
              out += REPLACEMENT;
            }
          } else if (c >= 0xDC00 && c <= 0xDFFF) { // lone low surrogate
            out += REPLACEMENT;
          } else {
            out += s[i];
          }
        }
        return out;
      },
      configurable: true
    });
  }
})();
```

使用方式：

```js
const s = 'Hi \uD83D'; // 非良构
if (!s.isWellFormed()) {
  console.log(s.toWellFormed()); // 'Hi '
}
```

## 6. FAQ

- 问：toWellFormed() 会不会影响正常字符？
  - 不会。只有在检测到非良构位置时才会替换为 U+FFFD，良构字符串原样返回。
- 问：我需要在每次显示前都调用 toWellFormed() 吗？
  - 推荐在「输入边界」或「存储/输出边界」统一处理一次；在性能敏感路径按需使用。
- 问：为什么我截断字符串后 emoji 显示成 ？
  - 因为把代理项对切开了，导致字符串非良构。应避免在代理项中间切分，或在切分后使用 toWellFormed() 修复。
- 问：是否与 normalize() 等价？
  - 不是。normalize() 处理 Unicode 规范化形式，isWellFormed()/toWellFormed() 只关注 UTF‑16 代理项的良构性。

## 7. 参考与扩展阅读

- ECMA-262（ES2024）：字符串良构性相关章节
- MDN Web Docs：String.prototype.isWellFormed / String.prototype.toWellFormed
- Unicode 标准与 UTF‑16 代理项说明
- Intl.Segmenter：基于“书写单元”的用户感知切分