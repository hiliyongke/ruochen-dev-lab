# ES2023 (ES14)

ECMAScript 2023 (ES14) 带来了几个备受期待的数组方法，它们提供了操作数组的不可变（immutable）版本，同时还增强了从数组末尾查找元素的能力。

## 1. 从数组末尾查找: `findLast()` 和 `findLastIndex()`

在 ES2023 之前，如果我们想从数组的末尾开始查找元素，通常需要先 `reverse()` 数组，这会原地修改原数组，或者使用一些更复杂的索引计算。

`findLast()` 和 `findLastIndex()` 提供了与 `find()` 和 `findIndex()` 类似的功能，但它们是从数组的最后一个元素开始向前搜索。

### `arr.findLast(callback)`

返回数组中满足测试函数条件的**最后一个元素**的值。否则返回 `undefined`。

### `arr.findLastIndex(callback)`

返回数组中满足测试函数条件的**最后一个元素**的索引。否则返回 `-1`。

```javascript
const numbers = [10, 25, 30, 45, 50];

// 查找最后一个大于 25 的数
const lastLargeNumber = numbers.findLast(n => n > 25);
console.log(lastLargeNumber); // 50

// 查找最后一个大于 25 的数的索引
const lastLargeIndex = numbers.findLastIndex(n => n > 25);
console.log(lastLargeIndex); // 4

const users = [
  { name: 'Alice', role: 'admin' },
  { name: 'Bob', role: 'user' },
  { name: 'Charlie', role: 'admin' }
];

// 查找最后一个管理员
const lastAdmin = users.findLast(user => user.role === 'admin');
console.log(lastAdmin); // { name: 'Charlie', role: 'admin' }
```

## 2. “原地修改”方法的副本版本

`reverse()`, `sort()`, 和 `splice()` 这三个数组方法会直接修改（mutate）调用它们的原始数组。这在很多情况下会导致意外的副作用，尤其是在函数式编程或使用像 React/Vue 这样的状态管理库时。

ES2023 引入了它们对应的“副本”版本，这些新方法会返回一个修改后的**新数组**，而保持原始数组不变。

### `arr.toReversed()` -> `Array`

返回一个元素顺序相反的新数组。

```javascript
const original = [1, 2, 3, 4];
const reversed = original.toReversed();

console.log(original); // [1, 2, 3, 4] (未改变)
console.log(reversed); // [4, 3, 2, 1]
```

### `arr.toSorted(compareFn)` -> `Array`

返回一个元素按升序排序的新数组。可以接受一个可选的比较函数。

```javascript
const unsorted = [3, 1, 4, 1, 5, 9];
const sorted = unsorted.toSorted();

console.log(unsorted); // [3, 1, 4, 1, 5, 9] (未改变)
console.log(sorted);   // [1, 1, 3, 4, 5, 9]
```

### `arr.toSpliced(start, deleteCount, ...items)` -> `Array`

返回一个在给定索引处删除、替换或添加了元素的新数组。

```javascript
const months = ['Jan', 'Mar', 'Apr', 'May'];

// 在索引 1 处插入 'Feb'
const spliced = months.toSpliced(1, 0, 'Feb');

console.log(months);   // ['Jan', 'Mar', 'Apr', 'May'] (未改变)
console.log(spliced);  // ['Jan', 'Feb', 'Mar', 'Apr', 'May']
```

### `arr.with(index, value)` -> `Array`

这是一个全新的方法，用于返回一个在指定索引处替换了值的新数组。它提供了一种不可变的方式来更新数组中的单个元素，比使用 `map` 或 `slice` + `splice` 更简洁。

```javascript
const scores = [10, 20, 30, 40];

// 更新索引 2 处的值
const updatedScores = scores.with(2, 35);

console.log(scores);        // [10, 20, 30, 40] (未改变)
console.log(updatedScores); // [10, 20, 35, 40]
```

这些新的数组方法极大地增强了 JavaScript 在处理不可变数据时的能力，使代码更安全、更可预测。

## 3. 其他特性

- **Hashbang Grammar**: 标准化了在 JavaScript 脚本文件开头使用 `#!` (shebang/hashbang) 的语法，例如 `#!/usr/bin/env node`，以指定脚本的解释器。这主要用于在 Unix-like 系统中编写可执行的 JS 文件。
- **Symbols as WeakMap keys**: 允许使用唯一的 `Symbol` 作为 `WeakMap` 的键，扩展了 `WeakMap` 的使用场景。