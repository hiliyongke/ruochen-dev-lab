# ES2021 (ES12)

ECMAScript 2021 (ES12) 继续为 JavaScript 语言添砖加瓦，带来了一些开发者期待已久的功能，例如 `replaceAll`，以及新的 Promise 组合器和逻辑赋值运算符。

## 1. `String.prototype.replaceAll()`

在 ES2021 之前，如果你想替换一个字符串中**所有**的子串，你需要使用 `split` 和 `join`，或者使用带全局标志 (`g`) 的正则表达式。

```javascript
const str = 'I love cats. My cat is a cute cat.';

// 使用正则表达式
const newStr1 = str.replace(/cat/g, 'dog');
console.log(newStr1); // 'I love dogs. My dog is a cute dog.'

// 如果只用字符串，replace 只会替换第一个匹配项
const newStr2 = str.replace('cat', 'dog');
console.log(newStr2); // 'I love dogs. My cat is a cute cat.'
```

`replaceAll()` 提供了一个直接、清晰的方法来替换所有匹配的子串，无需使用正则表达式。

**语法**：`str.replaceAll(pattern, replacement)`
- `pattern`: 可以是一个字符串，也可以是一个正则表达式。
- `replacement`: 用于替换的字符串或函数。

```javascript
const str = 'I love cats. My cat is a cute cat.';
const newStr = str.replaceAll('cat', 'dog');
console.log(newStr); // 'I love dogs. My dog is a cute dog.'
```

## 2. `Promise.any()`

`Promise.any()` 是继 `Promise.all()`, `Promise.race()`, `Promise.allSettled()` 之后的又一个 Promise 组合器。

它接收一个 Promise 的可迭代对象。只要其中**任何一个** Promise 成功（`fulfilled`），`Promise.any()` 返回的 Promise 就会立即以那个成功的值 `fulfill`。

只有当**所有**的 Promise 都失败（`rejected`）时，`Promise.any()` 返回的 Promise 才会 `reject`，并且会抛出一个 `AggregateError` 错误，这是一个新的错误类型，它的 `errors` 属性包含了一个由所有拒绝原因组成的数组。

```javascript
const promise1 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 1'));
const promise2 = new Promise((resolve, reject) => setTimeout(resolve, 200, 'Success'));
const promise3 = new Promise((resolve, reject) => setTimeout(reject, 300, 'Error 3'));

// 只要有一个成功，就返回那个成功的结果
Promise.any([promise1, promise2, promise3])
  .then(value => {
    console.log('Success:', value); // 'Success'
  })
  .catch(error => {
    console.log('This will not be called.');
  });

const failingPromises = [
  new Promise((resolve, reject) => reject('Fail 1')),
  new Promise((resolve, reject) => reject('Fail 2')),
];

// 所有都失败，则抛出 AggregateError
Promise.any(failingPromises)
  .catch(e => {
    console.log(e instanceof AggregateError); // true
    console.log(e.errors); // ['Fail 1', 'Fail 2']
  });
```

这在需要从多个来源获取相同数据，并且只要有一个来源成功返回即可的场景下非常有用（例如，从多个 CDN 节点请求同一个资源）。

## 3. 逻辑赋值运算符 (Logical Assignment Operators)

ES2021 引入了三个新的逻辑赋值运算符，它们是逻辑运算符和赋值运算符的结合，可以简化代码。

- **`&&=` (逻辑与赋值)**: `x &&= y` 等同于 `x = x && y`。仅当 `x` 为真值 (truthy) 时，才将 `y` 赋值给 `x`。
- **`||=` (逻辑或赋值)**: `x ||= y` 等同于 `x = x || y`。仅当 `x` 为假值 (falsy) 时，才将 `y` 赋值给 `x`。
- **`??=` (空值合并赋值)**: `x ??= y` 等同于 `x = x ?? y`。仅当 `x` 为 `null` 或 `undefined` 时，才将 `y` 赋值给 `x`。

```javascript
let a = { duration: 50 };
let b = { duration: 50 };
let c = { duration: 50 };

// 之前：if (!a.duration) a.duration = 10;
// 现在：
a.duration ||= 10;
console.log(a.duration); // 50 (因为 a.duration 是 truthy)

let user = { name: 'Yorke' };
// 之前：if (user.isAdmin) user.isAdmin = false;
// 现在：
user.isAdmin &&= false;
console.log(user.isAdmin); // undefined (因为 user.isAdmin 是 falsy)

let options = { speed: null };
// 之前：if (options.speed === null || options.speed === undefined) options.speed = 100;
// 现在：
options.speed ??= 100;
console.log(options.speed); // 100
```
`??=` 在设置默认配置时尤其有用，因为它不会覆盖 `0` 或空字符串 `''` 等有效的 "falsy" 值。

## 4. 数字分隔符 (Numeric Separators)

为了提高长数字的可读性，ES2021 允许在数字字面量中使用下划线 `_` 作为分隔符。

```javascript
const billion = 1_000_000_000;
console.log(billion); // 1000000000

const hex = 0xFF_EC_DE_5E;
console.log(hex); // 4293713502

const binary = 0b1010_0001_1000_0101;
console.log(binary); // 41349
```
这个分隔符不会影响数字的值，JavaScript 引擎会忽略它。它纯粹是为了方便开发者阅读。

## 5. WeakRef

`WeakRef` (弱引用) 对象允许你持有对另一个对象的弱引用，而不会阻止该对象被垃圾回收机制回收。这是一个高级特性，主要用于需要缓存或映射大对象，但又不希望这些缓存阻止对象被销毁的场景。由于其复杂性和潜在的非确定性行为，应谨慎使用。