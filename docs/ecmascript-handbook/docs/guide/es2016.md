# ES2016 (ES7)

ECMAScript 2016 (简称 ES7) 是一个小规模的年度更新，但它带来了两个非常实用和方便的特性：`Array.prototype.includes()` 和指数运算符 (`**`)。

## 1. `Array.prototype.includes()`

在 ES7 之前，如果我们想检查一个数组是否包含某个特定元素，通常会使用 `indexOf()` 方法，并检查其返回值是否不为 `-1`。

```javascript
const arr = [1, 2, 3, NaN];

if (arr.indexOf(2) !== -1) {
  console.log('数组包含 2');
}
```

这种写法不够直观，并且 `indexOf()` 无法正确处理 `NaN`。

```javascript
console.log(arr.indexOf(NaN)); // -1 (无法找到 NaN)
```

`includes()` 方法解决了这两个问题。它返回一个布尔值，表示数组是否包含给定的值，语法更清晰，并且可以正确查找 `NaN`。

### 语法

`arr.includes(valueToFind[, fromIndex])`

-   `valueToFind`: 需要查找的元素值。
-   `fromIndex` (可选): 从该索引处开始查找。默认为 0。

### 示例

```javascript
const pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));    // true
console.log(pets.includes('at'));     // false

const data = [1, 2, 3, NaN, -0];

// 可以查找 NaN
console.log(data.includes(NaN));      // true

// 可以区分 +0 和 -0
console.log(data.includes(0));        // true (因为数组中有 -0)
```

`includes()` 的出现，使得数组中的元素存在性检查变得更加简单和可靠。

## 2. 指数运算符 (`**`)

在 ES7 之前，计算一个数的幂需要使用 `Math.pow()` 方法。

```javascript
// 计算 2 的 10 次方
const powerOld = Math.pow(2, 10); // 1024
```

ES7 引入了中缀指数运算符 `**`，使得幂运算的表达方式更加自然，更接近数学写法。

```javascript
// 使用指数运算符
const powerNew = 2 ** 10; // 1024
```

`**` 是一个右结合运算符，这意味着 `a ** b ** c` 等同于 `a ** (b ** c)`。

```javascript
console.log(2 ** 3 ** 2); // 512, 等同于 2 ** 9
console.log((2 ** 3) ** 2); // 64, 等同于 8 ** 2
```

它也支持赋值运算符 `**=`。

```javascript
let num = 3;
num **= 4; // 等同于 num = num ** 4
console.log(num); // 81