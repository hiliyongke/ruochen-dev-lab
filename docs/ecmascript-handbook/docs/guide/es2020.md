# ES2020 (ES11)

ECMAScript 2020 (ES11) 是一个引入了大量重要特性的版本，其中一些（如可选链和空值合并）已经从根本上改变了我们编写 JavaScript 的方式。

## 1. 可选链操作符 (`?.`)

在 ES2020 之前，访问一个深度嵌套对象上的属性时，你需要对路径上的每个属性进行检查，以避免因中间某个属性为 `null` 或 `undefined` 而导致程序抛出 `TypeError`。

```javascript
// 之前的写法
const street = user && user.address && user.address.street;
```

可选链操作符 `?.` 简化了这一过程。它允许你安全地读取深度嵌套对象中的属性值。如果 `?.` 左侧的引用为 `null` 或 `undefined`，表达式会停止计算并返回 `undefined`，而不会抛出错误。

```javascript
const user = {
  name: 'Yorke',
  address: {
    city: 'Shanghai'
  }
};

// 使用可选链
const street = user?.address?.street;
console.log(street); // undefined (安全返回)

const city = user?.address?.city;
console.log(city); // 'Shanghai'
```

它也适用于函数调用和数组访问。

```javascript
// 如果 user.customMethod 存在，则调用它
user.customMethod?.();

// 安全地访问数组元素
const firstElement = anArray?.[0];
```

## 2. 空值合并操作符 (`??`)

逻辑或操作符 (`||`) 经常被用来为变量提供默认值。但它的问题是，它会对所有 "falsy" 值（如 `''`, `0`, `false`）生效，这有时并非我们所期望的。

```javascript
const quantity = 0;
const finalQuantity = quantity || 10; // 结果是 10，但我们可能期望是 0
```

空值合并操作符 `??` 解决了这个问题。它只在左侧表达式的值为 `null` 或 `undefined` 时，才会返回右侧的表达式。

```javascript
const quantity = 0;
const finalQuantity = quantity ?? 10; // 结果是 0

const missingValue = null;
const defaultValue = missingValue ?? 'Default'; // 结果是 'Default'
```

`??` 和 `?.` 经常一起使用，为可能不存在的属性提供一个安全的默认值。

```javascript
const userName = user?.profile?.name ?? 'Guest';
```

## 3. `Promise.allSettled()`

`Promise.all()` 的问题在于，只要有一个 Promise 失败（rejected），它就会立即失败。而 `Promise.allSettled()` 会等待所有给定的 Promise 都已经 `fulfilled` 或 `rejected` 后，返回一个描述每个 Promise 结果的对象数组。

这在你需要知道一组异步操作中每一个操作的最终结果，而不管它们是成功还是失败时，非常有用。

```javascript
const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));

Promise.allSettled([promise1, promise2]).
  then((results) => results.forEach((result) => console.log(result)));

// 输出:
// { status: 'fulfilled', value: 3 }
// { status: 'rejected', reason: 'foo' }
```

## 4. `BigInt`

`BigInt` 是 JavaScript 的第八种原始类型。它提供了一种表示大于 `2^53 - 1` 的整数的方式，这是 `Number` 类型所能表示的最大安全整数。

通过在整数末尾附加一个 `n` 或者调用 `BigInt()` 构造函数来创建 `BigInt`。

```javascript
const largestNumber = Number.MAX_SAFE_INTEGER; // 9007199254740991

const alsoHuge = 9007199254740991n;
const hugeSum = alsoHuge + 1n;

console.log(hugeSum); // 9007199254740992n
```

**注意**：`BigInt` 和 `Number` 是两种不同的类型，不能混合进行数学运算。

## 5. `globalThis`

在 JavaScript 中，访问全局对象的方式在不同环境中是不同的：
- 在浏览器中，是 `window`、`self` 或 `frames`。
- 在 Node.js 中，是 `global`。
- 在 Web Workers 中，是 `self`。

`globalThis` 提供了一个标准化的方式，在任何环境下都能获取到全局 `this` 对象。

```javascript
// 在任何环境中，globalThis 都会指向全局对象
console.log(globalThis);
```

## 6. `String.prototype.matchAll()`

`matchAll()` 方法返回一个包含所有匹配正则表达式的结果的迭代器，包括捕获组。这比循环调用 `regex.exec()` 要方便得多。

```javascript
const regexp = /t(e)(st(\d?))/g;
const str = 'test1test2';

const array = [...str.matchAll(regexp)];

console.log(array[0]);
// ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', groups: undefined]

console.log(array[1]);
// ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', groups: undefined]
```

## 7. 动态 `import()`

标准的 `import` 语句是静态的，必须在模块的顶层使用。动态 `import()` 允许你像调用函数一样，在代码的任何地方异步地加载一个模块。它返回一个 Promise，该 Promise 在模块加载完成后 `resolve` 为模块对象。

这对于按需加载模块（代码分割）非常有用。

```javascript
const button = document.getElementById('load-module-btn');

button.addEventListener('click', async () => {
  try {
    const module = await import('./utils.js');
    module.doSomething();
  } catch (error) {
    console.error('Failed to load module:', error);
  }
});