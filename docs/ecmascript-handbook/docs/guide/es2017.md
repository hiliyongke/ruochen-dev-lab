# ES2017 (ES8)

ECMAScript 2017 (ES8) 是一个重要的版本，它带来了革命性的 `async/await`（已在前面章节单独介绍）。除此之外，它还引入了多个用于对象和字符串处理的新工具，进一步增强了语言的表达能力。

## 1. `Object.values()` 和 `Object.entries()`

在 ES5 引入 `Object.keys()` 之后，开发者可以方便地获取一个对象的所有键。ES2017 则补全了这一能力，提供了 `Object.values()` 和 `Object.entries()`。

### `Object.values(obj)`

该方法返回一个给定对象自身的所有可枚举属性值的数组。

```javascript
const obj = { a: 1, b: 'hello', c: true };
console.log(Object.values(obj)); // [1, "hello", true]
```

这在需要遍历对象的值时非常方便，无需先获取键再通过键来取值。

### `Object.entries(obj)`

该方法返回一个给定对象自身可枚举属性的键值对数组。每个键值对都是一个 `[key, value]` 形式的数组。

```javascript
const obj = { a: 1, b: 'hello' };
console.log(Object.entries(obj)); // [ ['a', 1], ['b', 'hello'] ]
```

`Object.entries()` 最强大的地方在于，它可以非常方便地将一个普通对象转换成 `Map` 结构，或者在 `for...of` 循环中同时遍历键和值。

```javascript
// 对象转 Map
const map = new Map(Object.entries(obj));
console.log(map.get('a')); // 1

// 遍历键值对
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}
// a: 1
// b: hello
```

## 2. 字符串填充：`padStart()` 和 `padEnd()`

ES2017 引入了两个字符串方法，`padStart()` 和 `padEnd()`，用于在字符串的头部或尾部填充指定的字符，直到字符串达到目标长度。

### `str.padStart(targetLength [, padString])`

-   `targetLength`: 填充后字符串的总长度。
-   `padString` (可选): 用于填充的字符串。默认为空格。

### `str.padEnd(targetLength [, padString])`

参数与 `padStart` 相同，但填充在字符串的末尾。

### 示例

这在格式化日期、数字或对齐文本时非常有用。

```javascript
// 格式化日期
const day = '5';
console.log(day.padStart(2, '0')); // '05'

const month = '12';
console.log(month.padStart(2, '0')); // '12' (长度已满足，不填充)

// 格式化金额
const price = '99.9';
console.log(price.padEnd(6, '0')); // '99.900'

// 文本对齐
console.log('abc'.padStart(10)); // '       abc'
```

## 3. `Object.getOwnPropertyDescriptors()`

`Object.getOwnPropertyDescriptor()` 用于获取一个对象某个属性的描述符（descriptor）。而 ES2017 引入的 `Object.getOwnPropertyDescriptors()` 则可以一次性获取一个对象**所有**自身属性（非继承属性）的描述符。

一个属性的描述符包含了 `value`, `writable`, `enumerable`, `configurable` 等元信息。

```javascript
const person = {
  name: 'Yorke',
  get age() { return 30; }
};

const descriptors = Object.getOwnPropertyDescriptors(person);
console.log(descriptors);
/*
{
  name: {
    value: 'Yorke',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    get: [Function: get age],
    set: undefined,
    enumerable: true,
    configurable: true
  }
}
*/
```

这个方法的主要用途是配合 `Object.defineProperties()` 来实现一个**真正的浅拷贝**，特别是能够正确地拷贝 `getter` 和 `setter` 以及属性的元特征，这是 `Object.assign()` 无法做到的。

```javascript
// 使用 Object.assign() 无法正确拷贝 getter
const clone1 = Object.assign({}, person);
console.log(Object.getOwnPropertyDescriptors(clone1).age.get); // undefined
console.log(clone1.age); // 30 (getter 被执行并作为值赋给了新对象)

// 使用 getOwnPropertyDescriptors 可以实现更完整的拷贝
const descriptors = Object.getOwnPropertyDescriptors(person);
const clone2 = Object.create(Object.getPrototypeOf(person), descriptors);
console.log(Object.getOwnPropertyDescriptors(clone2).age.get); // [Function: get age]
console.log(clone2.age); // 30
```

## 4. 函数参数列表和调用中的尾随逗号

ES2017 允许在函数定义和函数调用的参数列表末尾添加一个逗号，而不会抛出语法错误。

```javascript
// 函数定义
function process(
  param1,
  param2, // 允许
) {
  // ...
}

// 函数调用
process(
  'value1',
  'value2', // 允许
);
```

这个小改动在版本控制中非常有用。当你添加一个新的参数时，你只需要新加一行，而不需要修改之前最后一行的代码（即给它补上一个逗号），这使得 `git diff` 的记录更加清晰。